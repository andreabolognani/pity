\section{Sorting}

Un sorting \`e, a livello di formalismo matematico, una funzione che
accetta in input un sort e restituisce una lista non vuota di sort.

L'implementazione dei sorting in Pity utilizza una
\emph{hash table} per ragioni di performance; questa scelta viene
comunque nascosta all'utente, che pu\`o fare uso del sorting senza
doversi preoccupare dei dettagli implementativi.

La struttura \lstinline{sorting} \`e definita come

\begin{lstlisting}
    (struct sorting (mappings)
                    #:transparent)
\end{lstlisting}

Si pu\`o notare che questa struttura, contrariamente a quelle viste
finora, non \`e protetta da una guardia: la presenza di una guardia si
rivela superflua perch\'e il costruttore non verr\`a mai chiamato
dall'esterno del modulo.

La costruzione di un sorting vuoto avviene tramite la seguente procedura:

\begin{lstlisting}
    ; empty-sorting : -> sorting?
    (define (empty-sorting)
      (sorting (hash)))
\end{lstlisting}

che costruisce un'istanza di \lstinline{sorting} contenente un
\lstinline{hash} vuoto.

La procedura \lstinline{empty-sorting} viene esportata all'esterno con
il nome \lstinline{sorting} usando la sintassi

\begin{lstlisting}
    (provide/contract
      [rename empty-sorting sorting (-> sorting?)])
\end{lstlisting}

Questo accorgimento consente di non esporre all'esterno del modulo il
fatto che i sorting siano implementati usando \lstinline{hash};
all'interno del modulo, la procedura \lstinline{sorting} fa riferimento
al costruttore.

Per aggiungere mappature ad un sorting si usa la procedura
\lstinline{sorting-set}, definita come

\begin{lstlisting}
    ; sorting-set : sorting? sort? (non-empty-listof sort?)
    ;            -> sorting?
    (define (sorting-set self subj obj)
      (let ([mappings (sorting-mappings self)])
        (sorting (hash-set mappings subj obj))))
\end{lstlisting}

Il funzionamento \`e molto semplice: il campo \lstinline{mappings}
viene estratto dal sorting, e viene restituito un nuovo sorting che
contiene l'hash ottenuto aggiungendo la mappatura da \lstinline{subj} a
\lstinline{obj} all'hash iniziale. Si noti che eventuali mappature per
\lstinline{subj} presenti nell'hash iniziale vengono sostituite.

Per ottenere la lista di sort assegnata ad un determinato sort si
usa la procedura \lstinline{sorting-ref}, definita come

\begin{lstlisting}
    ; sorting-ref : sorting? sort?
    ;            -> (or/c (non-empty-listof sort?) #f)
    (define (sorting-ref self subj)
      (let ([mappings (sorting-mappings self)])
        (hash-ref mappings subj #f)))
\end{lstlisting}

che distingue il caso in cui una mappatura per \lstinline{subj} non sia
presente restituendo \lstinline{#f}; l'uso di \lstinline{or/c} dichiara
che solo uno tra i contratti \lstinline{(non-empty-listof sort?)} e
\lstinline{#f} viene rispettato dal valore restituito.

Volendo rimuovere una mappatura da un sorting, si pu\`o usare la
procedura \lstinline{sorting-remove}, definita come

\begin{lstlisting}
    ; sorting-remove: sorting? sort? -> sorting?
    (define (sorting-remove self subj)
      (let ([mappings (sorting-mappings self)])
        (sorting (hash-remove mappings subj))))
\end{lstlisting}

che internamente chiama \lstinline{hash-remove} per cancellare la
mappatura dall'hash contenuto nel sorting.

Anche calcolare il dominio del sorting \`e molto semplice:

\begin{lstlisting}
    ; sorting-domain : sorting? -> (setof sort?)
    (define (sorting-domain self)
      (let ([mappings (sorting-mappings self)])
        (list->set (hash-map mappings (lambda (s o) s)))))
\end{lstlisting}

La procedura \lstinline{hash-map} funziona in maniera simile alla
\lstinline{map}, ma lavora su hash, e passa come argomenti alla
procedura chiamata sia la chiave che il valore ad essa associato.

Dal momento che nel calcolo del dominio si \`e interessati unicamente
alla chiave, il valore viene scartato. La lista ottenuta \`e poi
trasformata in un insieme usando la procedura \lstinline{list->set}.

Cos\`i come avviene per i processi, anche per i sorting viene definita
per motivi di praticit\`a una semplice rappresentazione testuale.

Usando questa rappresentazione, il sorting

\begin{pilisting}
$
    \lambda(s) = (t,r) \;\;\;
    \lambda(t) = (s)   \;\;\;
    \lambda(r) = (r)
$
\end{pilisting}

pu\`o essere scritto come

\begin{termlisting}
\begin{lstlisting}
    s=(r,t);t=(s);r=(r)
\end{lstlisting}
\end{termlisting}

Per convertire un sorting nella sua rappresentazione testuale si usa
la procedura \lstinline{sorting->string}:

\begin{lstlisting}
    ; sorting->string : sorting? -> string?
    (define (sorting->string self)
      (let ([mappings (sorting-mappings self)])
        (string-join (hash-map mappings mapping->string) ";")))
\end{lstlisting}

che concatena con il separatore \lstinline{";"} le stringhe ottenute
chiamando la procedura \lstinline{mapping->string} su ognuna delle
coppie chiave-valore contenute nell'hash \lstinline{mappings}.

La procedura privata \lstinline{mapping->string} \`e definita come

\begin{lstlisting}
    (define (mapping->string key value)
      (string-append (sort->string key) "=("
                     (sort-list->string value) ")"))
\end{lstlisting}

Per operare la conversione opposta viene dichiarato un parser che fa
uso del lexer gi\`a dichiarato in precedenza:

\begin{lstlisting}
    (define sorting-parser
      (parser

        (start  sorting)
        (end    EOF)
        (tokens common-symbols common-values)
        (error  (lambda (a b c) (void)))

        (grammar

          (sorting
            [(part)                   (sorting-set (empty-sorting)
                                                   (car $1)
                                                   (cdr $1))]
            [(sorting SEMICOLON part) (sorting-set $1
                                                   (car $3)
                                                   (cdr $3))])

          (part
            [(sort EQ LP sorts RP)    (cons $1 $4)])

          (sorts
            [(sort)                   (list $1)]
            [(sort COMMA sorts)       (list* $1 $3)])

          (sort
            [(ID)                     (sort $1)]))))
\end{lstlisting}

Il non-terminale \lstinline{sorts} riconosce una lista di sort separati
da virgola; il non-terminale \lstinline{part} riconosce un'associazione
tra un sort e una lista di sort, e restituisce il \lstinline{cons} delle
due parti. La coppia viene poi separata nelle sue componenti quando
viene riconosciuto il non-terminale \lstinline{sorting}, e la relativa
associazione aggiunta al sorting.

La procedura \lstinline{string->sorting} chiama il parser per convertire
una stringa in un sorting:

\begin{lstlisting}
    ; string->sorting : string? -> sorting?
    (define (string->sorting str)
      (if (not (equal? str ""))
          (with-handlers
            ([exn:fail?
              (lambda (e)
                (raise (exn:fail "Parsing error"
                                 (exn-continuation-marks e))))])
            (let ([ip (open-input-string str)])
              (sorting-parser (lambda () (common-lexer ip)))))
          (empty-sorting)))
\end{lstlisting}

L'unica differenza tra \lstinline{string->process} e
\lstinline{string->sorting} \`e che, per semplificare il parser, il
sorting vuoto viene gestito direttamente dalla procedura: se la
stringa \lstinline{str} \`e vuota, viene restituito il sorting vuoto,
in caso contrario viene usato il parser.
