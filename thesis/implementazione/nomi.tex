\subsection{Nomi}

Come abbiamo visto, il concetto di nome \`e alla base del $\pi$-calcolo,
quindi viene naturale partire con l'implementazione proprio creando creando
un modo di rappresentare un nome.

Il modulo \lstinline{pity/name} contiene l'implementazione di un nome: il
punto di partenza \`e la dichiarazione di un nuovo tipo, chiamato proprio
\lstinline{name}, che verr\`a usato per rappresentare un nome. La
dichiarazione \`e la seguente:

\begin{lstlisting}
      (struct name (n)
                   #:guard name-guard
                   #:transparent)
\end{lstlisting}

La struttura dichiarata contiene un singolo campo, \lstinline{n}, ed \`e
dichiarata come \emph{trasparente} tramite l'uso della keyword
\lstinline{#:transparent}: le strutture trasparenti in Racket possono essere
confrontate in maniera naturale tramite il predicato standard
\lstinline{equal?}, il che solleva dall'onere di dover dichiarare una
procedura di confronto tra nomi, che si ridurrebbe al semplice confronto
tra le stringhe contenute nei rispettivi campi \lstinline{n}.

Inoltre, usando la keyword \lstinline{#:guard}, la procedura
\lstinline{name-guard} viene designata come \emph{guardia} per la struttura:
questo tipo di procedura viene utilizzata in una maniera particolare che \`e
bene spiegare, visto che ne verr\`a fatto ampio uso.

Racket \`e un linguaggio a tipizzazione dinamica; in quanto tale, non
richiede al programmatore di dichiarare il tipo n\'e delle variabili, n\'e
degli argomenti di una procedura: tuttavia, se una delle procedure standard
viene chiamata con argomenti non compatibili -- ad esempio, la procedura
\lstinline{car}, che lavora su coppie, viene chiamata con argomento
\lstinline{2} --  viene segnalato un errore.

Ci sono vari modi per ottenere lo stesso comportamento per le strutture e
le procedure definite dall'utente: uno di questi modi \`e appunto usare una
guardia, che consente di analizzare gli argomenti passati al costruttore e
di interrompere la costruzione se non sono di tipo compatibile.

La guardia per la struttura \lstinline{name} \`e

\begin{lstlisting}
      (define (name-guard n type-name)
        (when (not (id-string? n))
              (error type-name
                     (format "expected <id-string?>, given: ~a" n)))
        (values n))
\end{lstlisting}

Come prima cosa ci si assicura che \lstinline{n}, la stringa passata al
costruttore, rispetti il contratto \lstinline{id-string?}, emettendo un
errore in caso contrario; se il controllo \`e andato a buon fine, la
procedura prosegue restituendo il valore \lstinline{n} invariato, e la
costruzione del nome prosegue.

Il predicato \lstinline{id-string?} verifica che una stringa sia adatta
ad essere utilizzata come identificatore: nel nostro caso, un
identificatore deve essere costituito da un numero positivo di lettere,
eventualmente seguite da un numero positivo di cifre. Le motivazioni che
hanno dettato questa scelta verranno spiegate tra poco.

L'implementazione del predicato \`e resa estremamente semplice dal supporto
alle espressioni regolari di Racket:

\begin{lstlisting}
      (define (id-string? x)
        (and (string? x)
             (regexp-match #rx"^[a-zA-Z]+[0-9]*$" x)))
\end{lstlisting}

Il risultato della chiamata \`e \lstinline{#t} se \lstinline{x} \`e una
stringa che pu\`o essere usata come identificatore, \lstinline{#f}
altrimenti.

A questo punto vengono definite alcune routine di conversione tra nomi e
stringhe, che saranno utili pi\`u avanti:

\begin{lstlisting}
      (define (name->string n)
        (name-n n))

      (define (name-list->string lst)
        (string-join (map name->string lst) ","))

      (define (string->name-list str)
        (if (equal? str "")
            '()
            (map name (regexp-split #rx", *" str))))
\end{lstlisting}

La prima procedura, \lstinline{name->string}, estrae semplicemente la
stringa che rappresenta un nome, chiamando la procedura di supporto
\lstinline{name-n}; tale procedura viene generata in maniera automatica
dalla forma \lstinline{struct} per ognuno dei campi di una struttura.

La seconda procedura, \lstinline{name-list->string}, converte una lista
di nomi nella loro rappresentazione sotto forma di stringa, separandoli
con virgole. Per fare ci\`o, chiama \lstinline{name->string} su ognuno dei
nomi contenuti in \lstinline{lst} tramite \lstinline{map}, e usa
\lstinline{string-join} sulla lista di stringhe risultante.

L'ultima procedura, \lstinline{string->name-list}, svolge il compito opposto
a \lstinline{name-list->string}, ovvero accetta una stringa contenente una
serie di nomi separati da virgola e restituisce una lista contenente le
rispettive istanze della struttura \lstinline{name}.

Per fare questo, innanzitutto controlla se la stringa \`e vuota, e in quel
caso restituisce la lista vuota \lstinline{'()}; altrimenti, ottiene i vari
componenti separati da virgole della stringa iniziale con
\lstinline{regexp-split}, e chiama il costruttore \lstinline{name} su
ognuno di essi tramite \lstinline{map}.
