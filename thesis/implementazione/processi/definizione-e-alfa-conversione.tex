\subsection{Definizione e \texorpdfstring{$\alpha$}{alfa}-conversione}

Si possono individuare vari tipi di dati da definire, direttamente derivati
dalle definizioni matematiche: processo nullo (\lstinline{nil}), azione di
input (\lstinline{input}), azione di output (\lstinline{output}), prefisso
(\lstinline{prefix}), restrizione (\lstinline{restriction}), replicazione
(\lstinline{replication}) e composizione parallela (\lstinline{composition}).
Le definizioni sono identiche a quelle di \lstinline{name}, e vengono quindi
tralasciate.

Oltre ai predicati definiti automaticamente dalla sintassi
\lstinline{struct}, sono stati definiti due predicati di supporto:

\begin{lstlisting}
    ; process? : any/c -> boolean?
    (define (process? v)
      (or
        (nil? v)
        (prefix? v)
        (restriction? v)
        (replication? v)
        (composition? v)))

    ; action? : any/c -> boolean?
    (define (action? v)
      (or
        (input? v)
        (output? v)))

\end{lstlisting}

Questi predicati riconoscono rispettivamente ogni tipo di processo e ogni
tipo di azione; vengono usati anche nella definizione di contratti.

Come si \`e visto nella sezione dedicata al $\pi$-calcolo, \`e necessario
che siano rispettate alcune regole durante la costruzione di processi: ad
esempio, i nomi oggetto di un'azione devono essere distinti tra loro.

Con delle guardie adeguate, \`e possibile assicurarsi che azioni non
rispettose di questo requisito non vengano mai create: per le azioni viene
utilizzata una semplice guardia, che si limita a verificare che i parametri
passati al costruttore siano rispettivamente un nome e una lista non vuota
di nomi distinti.

La guardia per la replicazione \`e altrettanto semplice: \`e sufficiente
infatti assicurarsi che il parametro passato al costruttore sia un processo
tramite l'uso del predicato \lstinline{process?}.

Leggermente pi\`u complessa \`e la guardia della restrizione. Quando ci si
trova a restringere un nome $x$ in un processo $P$ si deve garantire che
$x$ non sia presente tra i nomi legati di $P$, se si vuole che il processo
risultante rispetti la propriet\`a di avere tutti i nomi legati distinti.

La guardia della restrizione garantisce che la propriet\`a sia sempre
verificata:

\begin{lstlisting}
    (define (restriction-guard x p type-name)
      (let ([bound (process-bound-names p)])
        (values x
                (if (not (set-member? bound x))
                    p
                    (process-refresh-name p x)))))
\end{lstlisting}

dove non \`e stato riportato il controllo iniziale sui tipi dei parametri,
il quale assicura che \lstinline{x} soddisfi \lstinline{name?} e
\lstinline{p} soddisfi \lstinline{process?}.

Tramite la sintassi \lstinline{let}, alla variabile \lstinline{bound} viene
assegnato l'insieme dei nomi legati del processo \lstinline{p}, ottenuto
con la chiamata \lstinline{(process-bound-names p)}; poi, se il nome
\lstinline{x} \`e tra questi, al posto di \lstinline{p} viene usato per la
costruzione della restrizione il processo restituito da
\lstinline{(process-refresh-name p x)}.

La definizione di \lstinline{process-bound-names}, cos\`i come quella delle
procedure ad essa strettamente collegate, \lstinline{process-free-names} e
\lstinline{process-names}, \`e direttamente derivata dalla teoria del
$\pi$-calcolo: nel caso dei nomi legati, ad esempio, si ha

\begin{lstlisting}
    ; process-bound-names : process? -> (setof name?)
    (define (process-bound-names process)
      (match process
        [(nil)             (bound-names/nil)]
        [(input x y)       (bound-names/input x y)]
        [(output x y)      (bound-names/output x y)]
        [(prefix a p)      (bound-names/prefix a p)]
        [(restriction x p) (bound-names/restriction x p)]
        [(replication p)   (bound-names/replication p)]
        [(composition p q) (bound-names/composition p q)]))
\end{lstlisting}

La procedura pubblica fa uso della sintassi \lstinline{match} per distinguere
il tipo di processo, e delega il calcolo dei nomi legati alle rispettive
procedure private specializzate:

\begin{lstlisting}
    ; Il processo nullo non ha nomi legati
    (define (bound-names/nil)
      (set))

    ; I nomi legati sono quelli in oggetto
    (define (bound-names/input x y)
      (list->set y))

    ; Un'azione di output non ha nomi legati
    (define (bound-names/output x y)
      (set))

    ; I nomi legati in un'azione dipendono dal tipo di azione
    (define (bound-names/action a)
      (match a
        [(input x y)  (bound-names/input x y)]
        [(output x y) (bound-names/output x y)]))

    ; I nomi legati in un prefisso sono quelli legati
    ; dall'azione, uniti a quelli legati nella continuazione
    (define (bound-names/prefix a p)
      (set-union (process-bound-names a)
                 (process-bound-names p)))

    ; I nomi legati in una restrizione sono quelli legati nel
    ; processo sotto restrizione e il nome oggetto della restrizione
    (define (bound-names/restriction x p)
      (set-union (set x)
                 (process-bound-names p)))

    ; I nomi legati non vengono modificati dalla replicazione
    (define (bound-names/replication p)
      (process-bound-names p))

    ; I nomi legati in una composizione sono i nomi legati nel primo
    ; processo uniti a quelli legati nel secondo processo
    (define (bound-names/composition p q)
      (set-union (process-bound-names p)
                 (process-bound-names q)))
\end{lstlisting}

Si pu\`o notare che la procedura \lstinline{process-bound-names} accetta
come parametro anche un \lstinline{input} o un \lstinline{output}, che
non rispettano il contratto \lstinline{process?}: questo semplifica la
scrittura di alcune procedure interne al modulo, e non causa problemi
agli utilizzatori esterni perch\'e il contratto usato per esportarla,
\lstinline{(process? . -> . (setof name?))}, impedisce un utilizzo scorretto
all'esterno del modulo.

La procedura \lstinline{process-refresh-name} permette di eliminare tutti
i riferimenti al nome \lstinline{x} da un processo \lstinline{p}
mantenendone invariato il significato, evitando cio\`e la cattura di nomi:
effettuare questo tipo di sostituzione \`e fondamentale per garantire che
i nomi legati in un processo siano distinti da tutti gli altri nomi.

Per implementare correttamente \lstinline{process-refresh-name}, tuttavia,
non \`e sufficiente che il nome designato sia sostituito con quello
restituito da \lstinline{name-refresh}: per capire come questo approccio
ingenuo potrebbe causare problemi, basti pensare che sostituire in questa
maniera il nome $x_1$ nel processo

\begin{pilisting}
$
    y(x_2) . \, \overline{x_1}\langle z\rangle . 0
$
\end{pilisting}

porta al processo

\begin{pilisting}
$
    y(x_2) . \, \overline{x_2}\langle z\rangle . 0
$
\end{pilisting}

che ha significato ben diverso da quello originale.

\`E necessario avere la capacit\`a di generare nomi che sono garantiti
essere nuovi, cio\`e non presenti nel processo corrente: per fare ci\`o, si
pu\`o usare la procedura privata \lstinline{fresh-name}

\begin{lstlisting}
    (define (fresh-name p n)
      (let* ([names (process-names p)]
             [m (name-refresh n)]
             [ok? (lambda (x)
                    (or (not (name-compatible? x m))
                        (equal? (name-max x m) m)))]
             [res (set-map names ok?)])
         (if (and (not (member #f res))
                  (not (set-member? names m)))
             m
             (fresh-name p m))))
\end{lstlisting}

Questa procedura trova un nome compatibile con \lstinline{n} che \`e
garantito non essere gi\`a presente in \lstinline{p}.

Il modo in cui lavora \`e concettualmente molto semplice: si limita a
chiamare \lstinline{name-refresh} finch\'e il nome ottenuto non \`e
un nome non presente in \lstinline{p}.

Per prima cosa, i nomi che hanno occorrenze in \lstinline{p} vengono
calcolati usando \lstinline{process-names}, poi il nome ottenuto chiamando
\lstinline{(name-refresh n)} viene assegnato alla variabile \lstinline{m}.

Si vuole trovare il nome compatibile con \lstinline{n}, non presente in
\lstinline{p}, con parte numerica maggiore: per verificare se
\lstinline{m} soddisfa queste condizioni, si dichiara un predicato di
supporto, \lstinline{ok?}, che accetta come parametro un nome e restituisce
\lstinline{#t} se tale nome \`e o non compatibile con \lstinline{m}, o ha
parte numerica minore.

Il predicato \lstinline{ok?} viene chiamato su tutti i nomi di \lstinline{p}
usando \lstinline{set-map}; la lista ottenuta, \lstinline{res}, contiene
una serie di valori di verit\`a.

Se questi non sono tutti uguali a \lstinline{#t}, vuol dire che tra i nomi
di \lstinline{p} almeno uno \`e compatibile con \lstinline{m} e ha parte
numerica maggiore: in tal caso, la funzione \lstinline{fresh-name} viene
chiamata nuovamente, questa volta con argomento \lstinline{m}, per tentare
il nome successivo.

Se invece tutti i confronti hanno avuto successo, viene eseguito un
controllo aggiuntivo per verificare che \lstinline{m} non sia gi\`a tra
i nomi di \lstinline{p} (condizione che si verifica ad esempio quando viene
chiesto di sostituire $x_1$ in $\overline{x_1}\langle x_2\rangle$), e il
nome \lstinline{m} viene restituito.

Serve una procedura che gestisca l'effettiva sostituzione di un nome
all'interno di un processo: questa procedura privata, chiamata
\lstinline{replace-name}, \`e definita come

\begin{lstlisting}
    (define (replace-name self n m)
      (match self
        [(nil)             (replace-name/nil n m)]
        [(input x y)       (replace-name/input x y n m)]
        [(output x y)      (replace-name/output x y n m)]
        [(prefix a p)      (replace-name/prefix a p n m)]
        [(restriction x p) (replace-name/restriction x p n m)]
        [(replication p)   (replace-name/replication p n m)]
        [(composition p q) (replace-name/composition p q n m)]))
\end{lstlisting}

e, come gi\`a nel caso di \lstinline{process-bound-names}, delega
l'implementazione a delle procedure pi\`u specifiche, che sono

\begin{lstlisting}
    ; Sostituisce un nome nel processo nullo
    (define (replace-name/nil n m)
      (nil))

    ; Sostituisce un nome nell'azione di input
    (define (replace-name/input x y n m)
      (let ([x1 (if (equal? x n) m x)]
            [y1 (list-replace y n m)])
        (input x1 y1)))

    ; Sostituisce un nome nell'azione di output
    (define (replace-name/output x y n m)
      (let ([x1 (if (equal? x n) m x)]
            [y1 (list-replace y n m)])
        (output x1 y1)))

    ; Sostituisce un nome in un'azione
    (define (replace-name/action a n m)
      (match a
        [(input x y)  (replace-name/input x y n m)]
        [(output x y) (replace-name/output x y n m)]))

    ; Sostituisce un nome in un prefisso
    (define (replace-name/prefix a p n m)
      (prefix (replace-name a n m)
              (replace-name p n m)))

    ; Sostituisce un nome in una restrizione
    (define (replace-name/restriction x p n m)
      (let ([x1 (if (equal? x n) m x)])
        (restriction x1 (replace-name p n m))))

    ; Sostituisce un nome in una replicazione
    (define (replace-name/replication p n m)
      (replication (replace-name p n m)))

    ; Sostituisce un nome in una composizione
    (define (replace-name/composition p q n m)
      (composition (replace-name p n m)
                   (replace-name q n m)))
\end{lstlisting}

Come si pu\`o vedere, \lstinline{replace-name} non effettua alcun
controllo sui nomi passati come parametro per garantire che non avvenga
la cattura di nomi; per questo, se si vuole che il processo ottenuto
abbia lo stesso significato di quello originale, bisogna avere cura di
utilizzare un nome totalmente nuovo: si pu\`o quindi combinare
\lstinline{replace-name} con \lstinline{fresh-name} nella seguente
maniera:

\begin{lstlisting}
    ; process-refresh-name : process? name? -> process?
    (define (process-refresh-name self n)
      (replace-name self n (fresh-name self n)))
\end{lstlisting}

per ottenere una sostituzione di nome che rispetta sempre il significato
del processo originale, evitando cattura di nomi ed ambiguit\`a.

La guardia per il prefisso \`e pi\`u complessa di quella della
restrizione:

\begin{lstlisting}
    (define (prefix-guard a p type-name)
      (let* ([refresh (lambda (q n)
                        (let* ([an (fresh-name a n)]
                               [qn (fresh-name q n)]
                               [nn (name-max an qn)])
                          (replace-name q n nn)))]
             [bound (process-bound-names p)]
             [bound (set-intersect bound (process-names a))]
             [bound (set->list bound)]
             [p (foldl (flip refresh) p bound)])
        (if (not (input? a))
            (values a p)
            (let* ([bound (process-bound-names a)]
                   [x (input-x a)]
                   [y (input-y a)]
                   [na (fresh-name a x)]
                   [np (fresh-name p x)]
                   [nn (name-max na np)]
                   [y (if (not (set-member? bound x))
                          y
                          (list-replace y x nn))]
                   [a (input x y)]
                   [p (if (not (set-member? bound x))
                          y
                          (replace-name p x nn))])
              (values a p)))))
\end{lstlisting}

dove ancora una volta sono stati tralasciati i controlli iniziali, che
assicurano \lstinline{a} rispetti il contratto \lstinline{action?} e
\lstinline{p} rispetti il contratto \lstinline{process?}.

Questa procedura si deve assicurare che due situazioni di errore vengano
gestite correttamente: la prima \`e quella che si verifica quando uno dei
nomi di \lstinline{a} \`e gi\`a presente tra i nomi legati di
\lstinline{p}, come ad esempio nel processo

\begin{pilisting}
$
    \overline{b}\langle c\rangle.a(b).0
$
\end{pilisting}

dove l'occorrenza di $b$ in $\overline{b}\langle c\rangle$ fa riferimento
ad un nome che \`e diverso da quello a cui fa riferimento l'occorrenza di
$b$ in $a(b)$; una volta effettuato il cambio di nomi, si ottiene il
processo

\begin{pilisting}
$
    \overline{b}\langle c\rangle.a(b_1).0
$
\end{pilisting}

uno degli infiniti processi $\alpha$-equivalenti all'originale, che non
presenta ambiguit\`a.

In questo primo caso \`e sufficiente rinominare l'occorrenza legata di $b$:
nella procedura \lstinline{prefix-guard}, si comincia con il dichiarare una
procedura di supporto, \lstinline{refresh}, che funziona nello stesso modo
di \lstinline{process-refresh-name}, ma si assicura che il nome usato per
la sostituzione non sia presente n\'e in \lstinline{p} n\'e in
\lstinline{a}, evitando quindi la cattura di nomi.

Definita questa procedura, si prosegue con l'assegnare alla variabile
\lstinline{bound} l'insieme dei nomi legati in \lstinline{p}, al quale
vengono sottratti tutti i nomi che non compaiono in \lstinline{a};
l'insieme viene poi convertito in una lista, e tramite la chiamata

\begin{lstlisting}
    (foldl (flip refresh) p bound)
\end{lstlisting}

ci sia assicura che i nomi trovati (che sono quelli problematici) siano
stati sostituiti da nomi non presenti n\'e in \lstinline{p} n\'e in
\lstinline{a}.

Se l'azione \`e di output, non serve controllare altro, e si pu\`o
procedere con la normale costruzione della struttura.

Se invece l'azione \`e di input, bisogna gestire la seconda situazione
d'errore, ovvero quella che si verifica in un processo quale

\begin{pilisting}
$
    a(a).\overline{a}\langle b\rangle.0
$
\end{pilisting}

dove la prima occorrenza di $a$ si riferisce ad un nome diverso da
quello a cui fanno riferimento le altre due occorrenze, quindi \`e
necessario operare un cambio di nome per differenziarla. La guardia
trasforma il processo in

\begin{pilisting}
$
    a(a_1).\overline{a_1}\langle b\rangle.0
$
\end{pilisting}

Anche in questo caso, si comincia con il trovare i nomi legati dall'azione
\lstinline{a}, e si usa la procedura \lstinline{fresh-name} per ottenere
una nuova versione del nome \lstinline{x} usato per la trasmissione: se il
nome in questione fa parte dei nomi legati da \lstinline{a}, viene
operata la sua sostituzione all'interno della lista \lstinline{y} di nomi
ricevuti.

Per quanto riguarda il processo \lstinline{p}, \`e sufficiente operare una
sostituzione per mezzo della procedura \lstinline{replace-name}.

Resta da considerare la costruzione di una \lstinline{composition}: la
guardia \`e

\begin{lstlisting}
    (define (composition-guard p q type-name)
      (letrec ([fix (lambda (procs names)
                      (if (null? names)
                          procs
                          (let* ([p (car procs)]
                                 [q (cdr procs)]
                                 [n (car names)]
                                 [names (cdr names)]
                                 [np (fresh-name p n)]
                                 [nq (fresh-name q n)]
                                 [nn (name-max np nq)])
                            (cond
                              [(set-member? (process-bound-names p)
                                            n)
                               (fix (cons (replace-name p n nn)
                                           q)
                                    names)]
                              [(set-member? (process-bound-names q)
                                            n)
                               (fix (cons p
                                          (replace-name q n nn))
                                    names)]))))])
        (let* ([bound (process-bound-names p)]
               [names (process-names q)]
               [err (set-intersect bound names)]
               [bound (process-bound-names q)]
               [names (process-names p)]
               [err (set-union err (set-intersect bound names))]
               [err (set->list err)]
               [procs (fix (cons p q) err)])
          (values (car procs)
                  (cdr procs)))))
\end{lstlisting}

dove \lstinline{p} e \lstinline{q} rispettano entrambi il contratto
\lstinline{process?}.

Questa guardia \`e pi\`u complessa di quella del prefisso, ma molto
simile nell'approccio; la difficolt\`a aggiuntiva deriva principalmente
dalla natura simmetrica del costrutto, che obbliga a controllare
entrambe le parti di una composizione.

Quando due processi vengono eseguiti in parallelo, bisogna assicurarsi
che nessuno dei due contenga legati dei nomi che sono presenti liberi
nell'altro: ad esempio, nel processo

\begin{pilisting}
$
    \overline{a}\langle b\rangle.0 \; | \;
    b(a).0
$
\end{pilisting}

l'occorrenza di sinistra del nome $a$ ha significato diverso rispetto
all'occorrenza di destra, quindi quest'ultima deve essere rinominata,
il processo ottenuto dall'applicazione della guardia \`e

\begin{pilisting}
$
    \overline{a}\langle b\rangle.0 \; | \;
    b(a_1).0
$
\end{pilisting}

che \`e $\alpha$-equivalente all'originale e rispetta i requisiti.

Per svolgere questo compito, viene dichiarata una procedura interna
chiamata \lstinline{fix}. La procedura accetta come parametri la coppia,
creata con la primitiva \lstinline{cons}, di processi su cui si sta
lavorando e una lista contenente i nomi problematici.

Se tale lista non \`e vuota (il controllo viene effettuato tramite il
predicato \lstinline{null?}) si estraggono i due processi dalla coppia
usando le primitive \lstinline{car} e \lstinline{cdr}, e si assegna il
primo nome della lista alla variabile \lstinline{n}.

Usando la procedura \lstinline{fresh-name} si trova un nuovo nome
derivato da \lstinline{n} sia nel processo \lstinline{p} che in
\lstinline{q}, e si sceglie quello che non compare in nessuno dei due
usando \lstinline{name-max}.

Una volta trovato il nuovo nome, \`e sufficiente sostituirlo a
\lstinline{n} nel processo dove quest'ultimo ha occorrenze legate: quale
dei due processi debba essere oggetto della sostituzione viene stabilito
dalla sintassi \lstinline{cond}; la procedura \lstinline{fix} viene poi
chiamata ricorsivamente sul resto dei nomi.

La lista dei nomi problematici viene generata alla chiamata della
procedura guardia, unendo l'insieme dei processi che sono liberi in
\lstinline{p} e legati in \lstinline{p} con quello dei nomi che, al
contrario, sono legati in \lstinline{p} e liberi in \lstinline{q}.

Assegnando le guardie descritte alle varie strutture utilizzate per
descrivere processi del $\pi$-calcolo, si ha la garanzia che i processi
generati rispettino sempre i requisiti necessari ad applicare le
regole di inferenza che stanno alla base del type system.
