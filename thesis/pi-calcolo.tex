\section{Il \texorpdfstring{$\pi$}{pi}-calcolo}

Il \emph{$\pi$-calcolo} \`e un formalismo matematico che consente di
modellare un insieme di processi paralleli e di studiare il loro
comportamento.

Si basa su un ristretto insieme di potenti astrazioni: alla base del
$\pi$-calcolo si trova il concetto di \emph{nome}, che rappresenta un
canale di comunicazione tra due processi. Nuovi canali di comunicazione
possono essere aperti tra due processi semplicemente inviando un nuovo
nome da un processo all'altro.

Le \emph{azioni} possibili sono

\begin{pilisting}
$
    \pi \;\; ::= \;\; \overline{x}\langle\tilde{y}\rangle
        \;\; |   \;\; x(\tilde{y})
$
\end{pilisting}

rispettivamente di output ed input, dove $\tilde{y}$ \`e in entrambi i casi
una lista non vuota $ y_1 \ldots y_n$ di nomi distinti tra loro.

I \emph{processi} vengono ottenuti combinando tra loro pi\`u azioni in uno
dei seguenti modi

\begin{pilisting}
$
    P \;\; ::= \;\; 0
      \;\; |   \;\; \pi.P
      \;\; |   \;\; P|P^{'}
      \;\; |   \;\; \nu z \, P
      \;\; |   \;\; !P
$
\end{pilisting}

Il processo nullo $0$ \`e utilizzato come punto di partenza per la
costruzione di qualsiasi processo di $\pi$-calcolo; ad ogni processo pu\`o
essere aggiunto come \emph{prefisso} un'azione, ottenendo come risultato un
processo che compie l'azione per poi comportarsi come il processo originale.

Un esempio \`e il processo

\begin{pilisting}
$
    \overline{a}\langle b\rangle.0
$
\end{pilisting}

che trasmette il nome $b$ sul canale $a$ prima di comportarsi come $0$,
ovvero fermarsi.

Tramite l'operatore $|$ \`e possibile creare una composizione di processi:
nel processo

\begin{pilisting}
$
    \overline{a}\langle b,c\rangle.0 \; | \;
    a(u,v).0
$
\end{pilisting}

il lato sinistro e quello destro dell'espressione sono entit\`a che agiscono
autonomamente.

In questo caso, il lato sinistro vuole inviare i nomi $b$ e $c$ tramite il
canale $a$, lo stesso che il lato destro usa per ricevere due nomi da
sostituire ad $u$ e $v$; una volta avvenuta la comunicazione, entrambi i
processi si riducono a $0$.

\`E evidente gi\`a da questo semplice esempio come, se si vuole che una
comunicazione abbia successo, sia necessario che entrambe le parti
concordino quantomeno sul numero di nomi da inviare: nel processo

\begin{pilisting}
$
    \overline{a}\langle x\rangle.0 \; | \;
    a(u,v).0
$
\end{pilisting}

il processo mittente invia un solo nome, mentre il processo destinatario
si aspetta di riceverne due. Il type system implementato ha proprio lo
scopo di garantire che una simile situazione non si venga mai a verificare.

L'operatore di \emph{restrizione} $\nu x$ consente di creare un nuovo nome
$x$, che pu\`o successivamente essere utilizzato per comunicare tra un
gruppo ristretto di processi. Nel sistema

\begin{pilisting}
$
    \nu x \, (
      \overline{x}\langle y\rangle.0 \; | \;
      x(z).0
    ) \; | \;
    a(b).0
$
\end{pilisting}

il primo ed il secondo processo sono in grado di comunicare tra di loro
utilizzando il nome $x$, cosa che non \`e possibile al terzo processo, che
si trova all'esterno dello scope di $x$ (rappresentato dalle parentesi che
racchiudono i primi due processi).

Nella modellazione di sistemi reali, raramente ci si trova ad analizzare
processi che, come quelli visti fino ad ora, sono in grado di eseguire una
singola comunicazione prima di ridursi al processo nullo: nella maggior
parte dei casi, il processo lavora in maniera ciclica.

Immaginando di voler descrivere, tramite il $\pi$-calcolo, il funzionamento
di un semplice Web server, si arriverebbe a qualcosa di simile a

\begin{pilisting}
$
    !s(c,q).(\nu r \, \overline{c}\langle r\rangle.0)
$
\end{pilisting}

dove $!$ \`e l'operatore di \emph{replicazione}, definito in maniera tale
che $!P$ si comporti come $P \; | \; !P$.

Il funzionamento \`e semplice: il server riceve sul canale $s$ i nomi $c$ e
$q$, che rappresentano rispettivamente il canale da usare per comunicare la
risposta al client e la sua richiesta. Una volta ricevuti questi dati, il
server procede a generare una risposta $r$, che invia al client sul nome $c$
precedentemente ricevuto, e a mettersi in attesa di una nuova richiesta.

Le occorrenze di $x$ in $\nu x \, P$ e in $ a(x).P$ sono \emph{leganti}:
questo significa che tutte le occorrenze successive di $x$ in $P$ fanno
riferimento allo stesso nome $x$. L'insieme dei nomi legati in un processo
$P$ si indica con $bn(P)$.

Le occorrenze di un nome che non sono nello scope di un'occorrenza legante
sono \emph{libere}: ad esempio, l'occorrenza di $a$ in
$\overline{a}\langle b\rangle.P$ \`e libera, mentre in
$\nu a \; \overline{a}\langle b\rangle.P$ il nome $a$ non ha occorrenze
libere. L'insieme dei nomi liberi in $P$ si indica con $fn(P)$.

L'insieme dei nomi di $P$ si definisce come $n(P) = fn(P) \cup bn(P)$.
