\chapter{Type inference}

Quanto visto finora fornisce una rappresentazione di tutti i concetti
matematici necessari all'implementazione del type system; a questo punto
rimane da descrivere l'implementazione in s\'e.

Descrivendo il type system, si \`e spiegato come, per affermare che
un processo $P$ rispetta un sorting $\lambda$, bisogni trovare un
ambiente $\Psi$ tale che sia possibile derivare $\Psi |- P$ usando le
regole di inferenza che costituiscono il type system.

\`E quindi necessario avere un modo per generare tutti gli ambienti
di partenza possibili, cos\`i da poterli provare uno ad uno.

Gli ambienti di partenza dipendono dal processo e dal sorting, e vengono
creati dalla procedura \lstinline{process-environment}:

\begin{lstlisting}
    ; process-environments : process? sorting?
    ;                     -> (setof environment?)
    (define (process-environments p srt)
      (let ([names (set->list (process-free-names p))]
            [sorts (set->list (sorting-domain srt))])
        (process-environments-real names sorts)))
\end{lstlisting}

Questa procedura crea due liste, una contenente i nomi liberi del
processo (gli unici che possono avere un sort associato nell'ambiente)
e l'altra i sort che compongono il dominio del sorting, e chiama una
procedura privata per svolgere il lavoro.

La procedura \lstinline{process-environments-real} \`e decisamente
pi\`u complessa:

\begin{lstlisting}
    (define (process-environments-real names sorts)
      (let ([collect (lambda (n envs)
                       (foldl (lambda (s acc)
                                (set-union
                                  acc
                                  (foldl (lambda (env int-acc)
                                           (set-add
                                             int-acc
                                             (environment-set
                                               env
                                               n
                                               s)))
                                         (set)
                                         envs)))
                              (set)
                              sorts))])
        (cond
          [(null? names) (set)]
          [(null? (cdr names)) (collect (car names)
                                        (list (environment)))]
          [else (collect (car names)
                         (set->list (process-environments-real
                                      (cdr names)
                                      sorts)))])))
\end{lstlisting}

Per costruire tutti gli ambienti, bisogna combinare i nomi con i sort
in tutti i modi possibili.

La procedura lavora ricorsivamente: nel caso base, in cui la lista di
nomi \`e vuota, viene restituito l'insieme vuoto; se il nome \`e uno solo
viene restituito l'insieme ottenuto chiamando la procedura interna
\lstinline{collect} con argomenti il nome e una lista contenente
solamente l'ambiente vuoto; se i nomi sono pi\`u di uno, la procedura
\lstinline{collect} viene chiamata con argomenti il primo nome e la
lista ottenuta tramite una chiamata ricorsiva a
\lstinline{process-environments-real} sul resto dei nomi.

La procedura interna \lstinline{collect} prende in input un nome e un
insieme di ambienti, e svolge la costruzione degli ambienti usando due
chiamate a \lstinline{foldl} una dentro l'altra: la chiamata pi\`u
esterna fissa il nome e itera sui sort, quella pi\`u interna fissa sia
nome che sort e itera sugli ambienti. L'iterazione \`e svolta creando
delle procedure al volo tramite la sintassi \lstinline{lambda}.

Quindi, ad ogni nome (chiamata a \lstinline{collect}) vengono messi in
relazione uno ad uno tutti i sort (chiamata esterna a \lstinline{foldl})
e la mappatura da nome a sort viene aggiunta ad ognuno degli ambienti
(chiamata interna a \lstinline{foldl}); l'ambiente ottenuto viene
aggiunto agli altri ambienti, e cos\`i via fino ad esaurire i nomi.

Come semplice esempio del funzionamento di questa procedura, si
consideri il seguente frammento di codice:

\begin{lstlisting}
    (define p (string->process "a(b,c).0"))
    (define s (string->sorting "t=(s);s=(s,t)"))
    (define envs (string-environments p s))

    (set-map envs environment->string) ; ==> (list "{a:t}" "{a:s}")
\end{lstlisting}

dove si pu\`o vedere chiaramente che uno dei due ambienti generati,
ovvero

\begin{pilisting}
$
    \{a:t\}
$
\end{pilisting}

non pu\`o essere valido, dal momento che il sorting indica che un nome
di sort $t$ trasmette un singolo nome, mentre il nome $a$ nel processo
d'esempio ne trasmette due.

La procedura \lstinline{process-environments} si limita a generare tutti
i possibili ambienti, validi o meno, e lascia ad altre parti del sistema
il compito di scartare quelli che non hanno senso.

La procedura pubblica \lstinline{process-respects?} si occupa proprio
di questo: dati un processo ed un sorting, genera tutti gli ambienti
possibili, e restituisce solamente quelli partendo dai quali \`e
possibile creare un albero di derivazione usando le regole di inferenza
che costituiscono il type system:

\begin{lstlisting}
    ; process-respects? : process? sorting?
    ;                  -> (setof environment?)
    (define (process-respects? p srt)
      (let* ([envs (process-environments p srt)]
             [collect (lambda (env)
                        (if (check-typing p srt env)
                            env
                            #f))]
             [res (filter (lambda (x) x) (set-map envs collect))])
        (if (null? res)
            #f
            (list->set res))))
\end{lstlisting}

Il funzionamento \`e molto semplice: tutti gli ambienti vengono generati
ed assegnati alla variabile \lstinline{envs}, poi la procedura interna
\lstinline{collect} viene applicata ad ognuno di essi tramite
\lstinline{set-map}.

\lstinline{collect} si limita a chiamare \lstinline{check-typing} e a
restituire l'ambiente se ha successo, \lstinline{#f} in caso contrario.

Tramite la chiamata a \lstinline{filter}, dalla lista ottenuta vengono
rimossi tutti i valori \lstinline{#f}, lasciando quindi solamente gli
ambienti per i quali \lstinline{check-typing} ha avuto successo: se
questa lista non \`e vuota, viene convertita in un insieme e restituita;
in caso contrario \lstinline{process-respects?} restituisce
\lstinline{#f}.

La procedura privata \lstinline{check-typing} applica le regole di
inferenza che formano il type system sui vari tipi di processo:

\begin{lstlisting}
   (define (check-typing process srt env)
     (match process
       [(nil)             (check-typing/nil srt env)]
       [(prefix a p)      (check-typing/prefix a p srt env)]
       [(restriction x p) (check-typing/restriction x p srt env)]
       [(replication p)   (check-typing/replication p srt env)]
       [(composition p q) (check-typing/composition p q srt env)]))
\end{lstlisting}

Le procedure chiamate da \lstinline{check-typing} sono in relazione
univoca con le regole di inferenza.

La procedura che implementa la regola

\begin{pilisting}
    \inference[nil ]
      {}
      {\Psi |- 0}
\end{pilisting}

\`e ovviamente la pi\`u semplice:

\begin{lstlisting}
    (define (check-typing/nil srt env)
      #t)
\end{lstlisting}

ovvero il processo nullo rispetta ogni sorting in ogni ambiente.

La regola di inferenza per la replicazione

\begin{pilisting}
    \inference[rep ]
      {\Psi |- P}
      {\Psi |- !P}
\end{pilisting}

\`e altrettanto semplice, dal momento che basta garantire che il
processo replicato rispetti il sorting:

\begin{lstlisting}
    (define (check-typing/replication p srt env)
      (check-typing p srt env))
\end{lstlisting}

Anche la regola per la composizione parallela

\begin{pilisting}
    \inference[par ]
      {\Psi |- P_1 & \Psi |- P_2}
      {\Psi |- P_1|P_2}
\end{pilisting}

si limita ad garantire che i due processi paralleli, presi singolarmente,
rispettino il sorting:

\begin{lstlisting}
    (define (check-typing/composition p q srt env)
      (and (check-typing p srt env)
           (check-typing q srt env)))
\end{lstlisting}

La regola per la restrizione \`e

\begin{pilisting}
    \inference[res ]
      {\Psi,z:s |- P}
      {\Psi |- (z)P}
\end{pilisting}

dove deve valere

\begin{pilisting}
$
    z \notin n(\Psi)
$
\end{pilisting}

che si traduce nella procedura

\begin{lstlisting}
    (define (check-typing/restriction x p srt env)
      (let ([names (environment-domain env)]
            [sorts (sorting-domain srt)]
            [bor (lambda (x y) (or x y))]
            [recur (lambda (s)
                     (if (environment-compatible? env x s)
                         (check-typing p
                                       srt
                                       (environment-set env x s))
                         #f))])
        (if (set-member? names x)
            #f
            (foldl bor #f (set-map sorts recur)))))
\end{lstlisting}

La procedura inizia controllando se \lstinline{x} \`e parte dominio
dell'ambiente, identificato dalla variabile \lstinline{names}: in tal
caso, viene restituito il valore \lstinline{#f}, visto che la condizione
sulla regola \`e stata violata.

In caso contrario, si procede con il controllo: per affermare che il
processo rispetta il sorting, bisogna verificare che il processo sotto
restrizione rispetti il sorting in un ambiente uguale a quello di
partenza, ma dove viene introdotta una mappatura dal nome oggetto
della restrizione a uno dei sort.

Viene effettuata un'iterazione sui sort tramite la chiamata a
\lstinline{set-map}: per ogni sort viene chiamata la procedura
interna \lstinline{recur}, che restituisce \lstinline{#f} se la
mappatura del nome oggetto della restrizione con il sort non \`e
compatibile con l'ambiente di partenza, e in caso contrario chiama
ricorsivamente \lstinline{check-typing} sul processo sotto restrizione
in un ambiente dove la mappatura in questione \`e stata aggiunta.

La chiamata a \lstinline{foldl} sulla lista ottenuta (che contiene
valori di verit\`a) con la procedura interna \lstinline{bor}, che
implementa un \lstinline{or} binario, fa s\`i che il risultato sia
\lstinline{#t} se la mappatura dal nome oggetto della restrizione ad
almeno uno dei sort consente una corretta derivazione del processo
sotto restrizione.

Non esiste una regola di inferenza per il prefisso in generale, quindi
quando si incontra un prefisso si delega il controllo alla procedura
per l'input o a quella per l'output in base al tipo di azione:

\begin{lstlisting}
    (define (check-typing/prefix a p srt env)
      (match a
        [(input x y)  (check-typing/input x y p srt env)]
        [(output x y) (check-typing/output x y p srt env)]))
\end{lstlisting}

La regola per l'output \`e

\begin{pilisting}
    \inference[out ]
      {\Psi |- P}
      {\Psi,x:s,y_1:t_1,\ldots,y_n:t_n |-
       \overline{x}\langle y_1\ldots y_n\rangle.P}
\end{pilisting}

con condizioni

\begin{pilisting}
$
    \lambda(s) = (t_1\ldots t_n), \Psi \simeq x : s,
    \Psi \simeq y_1 : t_1$ (per ogni $i$), $ x = y_i$ implica $ \\
$
\indent
$
    \; s = t_i$ (per qualche $i$) e $ y_i = y_j$ implica $
    t_i = t_j$ (per qualche $i$, $j$)
\end{pilisting}

ed \`e implementata dalla procedura

\begin{lstlisting}
    (define (check-typing/output x y p srt env)
      (let* ([s (environment-ref env x)]
             [sorts (environment-ref-multiple env y)]
             [obj-srt (if (not s) #f (sorting-ref srt s))])
        (if (or (not obj-srt) (not (equal? sorts obj-srt)))
            #f
            (check-typing
              p
              srt
              (environment-remove-multiple env (cons x y))))))
\end{lstlisting}

Come prima cosa, vengono estratti dall'ambiente il sort per il nome
\lstinline{x} e i sort per i nomi in \lstinline{y}, che vengono assegnati
rispettivamente alle variabili \lstinline{s} e \lstinline{sorts}.

Se il sort di \lstinline{x} non risulta essere \lstinline{#f}, cio\`e
se nell'ambiente esiste una mappatura relativa al nome, si usa
\lstinline{sorting-ref} per trovare la lista di sort oggetto per il
sort \lstinline{s} (sarebbe la lista $(t_1\ldots t_n)$ nelle condizioni)
e si assegna tale lista alla variabile \lstinline{obj-srt}.

Viene quindi effettuato un controllo per vedere se \lstinline{obj-srt}
\`e uguale a \lstinline{sorts}: se le due liste non coincidono, le
condizioni sulla regola di inferenza non sono rispettate, e il valore
restituito dalla procedura \`e \lstinline{#f}; se invece le due liste
contengono gli stessi valori, si effettua un controllo ricorsivo,
chiamando \lstinline{check-typing} sul processo che segue l'azione di
output nell'ambiente al quale vengono rimossi, tramite
\lstinline{environment-remove-multiple}, tutte le mappature relative
ai nomi coinvolti nell'azione.

L'ultima regola di inferenza \`e quella relativa alle azioni di input

\begin{pilisting}
    \inference[inp ]
      {\Psi,z_1:t_1,\ldots,z_n:t_n |- P}
      {\Psi,x:s |- x(z_1\ldots z_n).P}
\end{pilisting}

con condizioni

\begin{pilisting}
$
    \lambda(s) = (t_1\ldots t_n),
    \Psi \simeq x : s$ e $z_1,\ldots,z_n \notin n(\Psi)
$
\end{pilisting}

La procedura che implementa questa regola \`e

\begin{lstlisting}
    (define (check-typing/input x y p srt env)
      (let* ([names (environment-domain env)]
             [s (environment-ref env x)]
             [obj-srt (if (not s) #f (sorting-ref srt s))]
             [newenv (environment-remove env x)]
             [arity-ok? (and obj-srt
                             (= (length y) (length obj-srt)))])
        (if (or (set-member-any? names y)
                (not obj-srt)
                (not arity-ok?))
            #f
            (check-typing
              p
              srt
              (environment-set-multiple newenv y obj-srt)))))
\end{lstlisting}

Alle variabili \lstinline{s} e \lstinline{obj-srt} vengono assegnati
rispettivamente il sort per \lstinline{x} presente nell'ambiente, e la
lista di sort oggetto assegnati a \lstinline{s} nel sorting.

Il controllo sull'arit\`a dell'azione viene fatto controllando che la
lunghezza delle liste \lstinline{y} e \lstinline{obj-srt} siano uguali.

Se qualche nome presente in \lstinline{y} fa parte del dominio
dell'ambiente, o se dal nome \lstinline{x} non \`e possibile ricavare
una lista di sort oggetto, o ancora se l'arit\`a dell'operazione non
\`e corretta, la procedura restituisce il valore \lstinline{#f}; in
caso contrario, il controllo viene effettuato sul processo che segue
l'azione nell'ambiente al quale \`e stata tolta la mappatura per
\lstinline{x}, e ogni nome di \lstinline{y} \`e stato associato al
rispettivo sort di \lstinline{obj-srt}.

Con l'implementazione di queste procedure, \lstinline{process-respects?}
\`e in grado di svolgere il suo compito: dato un processo ed un sorting,
riesce a determinare non solo se il processo rispetta il sorting, ma
anche da quali ambienti bisogna partire per costruire un albero di
derivazione completo e corretto.
