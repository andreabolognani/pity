\section{Type system per il \texorpdfstring{$\pi$}{pi}-calcolo}

Per garantire che le comunicazioni tra i processi avvengano in maniera
corretta, viene fatto uso di un type system basato su regole di
inferenza\cite{qw05}.

Prima di introdurre le regole di inferenza che costituiscono il type system
vero e proprio, \`e necessario spiegare i concetti di \emph{sort} e
\emph{sorting}, indispensabili alla sua realizzazione.

Il concetto di sort nel $\pi$-calcolo \`e in qualche modo equivalente al
concetto di tipo in un linguaggio di programmazione: il sort assegnato ad un
nome determina sia quali altri nomi possano essere trasmessi o ricevuti usando
quel nome come canale di comunicazione, sia quali altri nomi possano
trasmettere o ricevere il nome in questione.

L'insieme dei sort \`e $\mathcal{S}$, e un sorting \`e una funzione
$\lambda : \mathcal{S} \rightarrow \mathcal{S}^{+}$ che assegna ad ogni sort
una lista non vuota di sort: un esempio di sorting pu\`o essere

\begin{pilisting}
$
    \lambda(s) = (t,r) \;\;\;
    \lambda(t) = (s)   \;\;\;
    \lambda(r) = (r)   \;\;\;\;\;\;
$
con $\mathcal{S} = \{s,t,r\}$
\end{pilisting}

Questo sorting stabilisce che un nome di sort $s$ possa trasmettere due
nomi, rispettivamente di sort $t$ e $r$; allo stesso modo, si pu\`o vedere
come un nome di sort $r$ possa essere trasmesso o come secondo nome su un
canale di sort $s$, sia come unico nome su un canale di sorting $r$.

Dato un processo $P$, la corrispondenza tra i vari nomi $x_i \in n(P)$ e
i rispettivi sort $s_i \in \mathcal{S}$ viene rappresentata da un
\emph{ambiente} $\Psi$.

Possiamo finalmente elencare le regole di inferenza che costituiscono il
type system:

\begin{pilisting}
\inference[nil ]
  {}
  {\Psi |- 0}

\vspace{3mm}
\indent
\inference[rep ]
  {\Psi |- P}
  {\Psi |- !P}

\vspace{3mm}
\indent
\inference[par ]
  {\Psi |- P_1 & \Psi |- P_2}
  {\Psi |- P_1|P_2}

\vspace{3mm}
\indent
\inference[res ]
  {\Psi,z:s |- P}
  {\Psi |- (z)P}
$\; (1)$

\vspace{3mm}
\indent
\inference[out ]
  {\Psi |- P}
  {\Psi,x:s,y_1:t_1,\ldots,y_n:t_n |- \overline{x}\langle y_1\ldots y_n\rangle.P}
$\; (2)$

\vspace{3mm}
\indent
\inference[inp ]
  {\Psi,z_1:t_1,\ldots,z_n:t_n |- P}
  {\Psi,x:s |- x(z_1\ldots z_n).P}
$\; (3)$
\end{pilisting}

dove le condizioni per le regole {\small res}, {\small out} e {\small inp}
sono rispettivamente

\vspace{3mm}
\indent
$
    (1) \; z \notin n(\Psi);
$
\vspace{3mm}
\\
\indent
 $
    (2) \; \lambda(s) = (t_1\ldots t_n),
           \Psi \simeq x : s,
           \Psi \simeq y_1 : t_1$ (per ogni $i$), $
           x = y_i$ implica $ \\
$
\indent
$
          \;\;\;\;\;
          s = t_i$ (per qualche $i$) e $
          y_i = y_j$ implica $t_i = t_j$ (per qualche $i$, $j$); $
$
\vspace{3mm}
\\
\indent
$
    (3) \; \lambda(s) = (t_1\ldots t_n),
           \Psi \simeq x : s$ e $z_1,\ldots,z_n \notin n(\Psi).
$
\vspace{3mm}

e la scrittura $\Psi \simeq x : s$ indica che l'ambiente $\Psi$ deve
essere \emph{compatibile} con $x:s$, cio\`e deve o contenere
un'associazione tra il nome $x$ e il sort $s$, oppure non contenere
alcuna associazione per il nome $x$.

Risulta ora evidente la motivazione che porta alla richiesta di avere
nomi distinti: se questa condizione non fosse verificataÂ¸ all'interno
dell'ambiente si dovrebbero assegnare ad uno stesso nome pi\`u sort,
potenzialmente in conflitto tra loro.

Inoltre, dal momento che nell'ambiente sono contenuti solamente i
sort dei nomi che hanno occorrenze libere, se un nome avesse sia
occorrenze libere che occorrenze legate in un processo, l'ambiente
dovrebbe contemporaneamente contenere e non contenere un'associazione
tra il nome in questione e il suo sort, il che \`e ovviamente un
assurdo.

Si dice che un processo $P$ \emph{rispetta} un sorting $\lambda$ se esiste
un qualche ambiente $\Psi$ tale che \`e possibile usare le regole di
inferenza appena descritte per derivare la conclusione $\Psi |- P$.

Ad esempio, si pu\`o verificare che il processo

\begin{pilisting}
$
    \overline{a}\langle b\rangle.0 \; | \;
    a(c).0
$
\end{pilisting}

rispetta il sorting $\lambda$ definito sopra negli ambienti
$\Psi_1 = \{a:t,b:s\}$ e $\Psi_2 = \{a:r,b:r\}$, usando rispettivamente
le derivazioni

\begin{pilisting}
\inference[]
  {\inference[]
     {\inference
        {}
        {\emptyset |- 0}}
     {\{a:t,b:s\} |- \overline{a}\langle b\rangle.0}
    &
   \inference[]
     {\inference[]
        {}
        {\{b:s,c:s\} |- 0}}
     {\{a:t,b:s\} |- a(c).0}}
  {\Psi_1 |- \overline{a}\langle b\rangle.0 \; | \; a(c).0}
\end{pilisting}

e

\begin{pilisting}
\inference[]
  {\inference[]
     {\inference
        {}
        {\emptyset |- 0}}
     {\{a:r,b:r\} |- \overline{a}\langle b\rangle.0}
    &
   \inference[]
     {\inference[]
        {}
        {\{b:r,c:r\} |- 0}}
     {\{a:r,b:r\} |- a(c).0}}
  {\Psi_2 |- \overline{a}\langle b\rangle.0 \; | \; a(c).0}
\end{pilisting}

Dati un sorting ed un ambiente di partenza, \`e relativamente semplice
verificare che un processo rispetti il sorting in quell'ambiente; come
si \`e appena visto, per\`o, gli ambienti di partenza validi potrebbero
essere pi\`u di uno, e in ogni caso verificare che un singolo ambiente
non consente di costruire un albero di derivazione completo non \`e
sufficiente per affermare che il processo non rispetta il sorting.

Un approccio sistematico d\`a garanzia di successo, ma soprattutto nel
caso di sistemi pi\`u complessi di quelli estremamente semplici visti
finora, pu\`o rivelarsi un lavoro lungo e facilmente soggetto ad
errori; questi sono alcuni dei motivi che portano all'interesse nello
sviluppo di un software in grado di effettuare in maniera automatica
tutti i controlli necessari a dimostrare se un processo rispetti un
determinato sorting.
